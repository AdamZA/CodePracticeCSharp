using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Practice2017.Project_Euler
{
    public class Problems
    {
        public static void Main(string[] args)
        {
            #region Q1
            //If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
            //Find the sum of all the multiples of 3 or 5 below 1000.
            int problemOneResult = 0;

            for (int i = 0; i < 1000; i++)
            {
                if (i % 3 == 0 || i % 5 == 0)
                {
                    problemOneResult += i;
                }
            }

            Debug.WriteLine("Problem 1: {0}", problemOneResult);
            #endregion
            #region Q2
            //Each new term in the Fibonacci sequence is generated by adding the previous two terms.By starting with 1 and 2, the first 10 terms will be:
            //1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
            //By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

            int firstSequenceTerm = 1;
            int secondSequenceTerm = 2;
            int problemTwoResult = 2;

            while (firstSequenceTerm + secondSequenceTerm < 4000000)
            {
                if ((firstSequenceTerm + secondSequenceTerm) % 2 == 0)
                {
                    problemTwoResult += firstSequenceTerm + secondSequenceTerm;
                }
                int placeholder = firstSequenceTerm;
                firstSequenceTerm = secondSequenceTerm;
                secondSequenceTerm += placeholder;
            }

            Debug.WriteLine("Problem 2: {0}", problemTwoResult);
            #endregion
            #region Q3
            //The prime factors of 13195 are 5, 7, 13 and 29.
            //What is the largest prime factor of the number 600851475143 ?
            var watch = Stopwatch.StartNew();

            long problemThreeResult = 0;
            long numberToTestAgainst = 600851475143;
            var upperLimit = numberToTestAgainst;
            if (numberToTestAgainst % 2 == 0)
            {
                upperLimit /= 2;
            }
            for (long i = (int)Math.Sqrt(upperLimit); i > 0; i--)
            {
                if (isPrime(i) && isFactor(i, numberToTestAgainst))
                {
                    problemThreeResult = i;
                    break;
                }
            }

            watch.Stop();
            var elapsedMs = watch.ElapsedMilliseconds;

            Debug.WriteLine("Problem 3: {0}", problemThreeResult);
            Debug.WriteLine("Time taken: {0}s", elapsedMs/1000.0);
            #endregion
            #region Q3 v2
            var watch2 = Stopwatch.StartNew();
            long problemThreeResultv2 = 0;
            long numberToTestAgainstv2 = 600851475143;
            var upperLimitv2 = numberToTestAgainstv2;
            if (numberToTestAgainstv2 % 2 == 0)
            {
                upperLimitv2 /= 2;
            }

            var primeList = getPrimesUpToTerm((long)Math.Sqrt(upperLimitv2));
            primeList.Reverse();

            foreach (long term in primeList)
            {
                if (numberToTestAgainstv2 % term == 0)
                {
                    problemThreeResultv2 = term;
                    break;
                }
            }


            watch2.Stop();
            var elapsedMs2 = watch2.ElapsedMilliseconds;
            Debug.WriteLine("Problem 3 v2: {0}", problemThreeResultv2);
            Debug.WriteLine("Time taken: {0}s", elapsedMs2/1000.0);
            #endregion
        }

        #region helperMethods
        private static bool isPrime(long term)
        {
            if (term == 1)
            {
                return false;
            }
            if (term == 2)
            {
                return true;
            }

            string stringTerm = term.ToString();
            List<string> exclusionList = new List<string> { "0", "2", "4", "5", "6", "8" };


            if (exclusionList.Contains(stringTerm[stringTerm.Length - 1].ToString()))
            {
                if (term != 5)
                {
                    return false;
                }

            }

            if (calculateTotalOfDigits(term) == 3 && term != 3)
            {
                return false;
            }

            bool factorFound = false;

            for (long i = 3; i < Math.Sqrt(term); i += 2)
            {
                if (term % i == 0 && term != i)
                {
                    factorFound = true;
                }
            }

            return !factorFound;
        }

        private static int calculateTotalOfDigits(long term)
        {
            int sum = 0;
            for (int i = 0; i < term.ToString().Length; i++)
            {
                sum += int.Parse(term.ToString()[i].ToString());
            }
            return sum;
        }

        private static bool isFactor(long testFactor, long testNumber)
        {
            return (testNumber % testFactor == 0);
        }

        private static int maxNumber = (int)Math.Sqrt(Int32.MaxValue);

        private static List<long> getPrimesUpToTerm(long term)
        {
            if (term <= 0)
            {
                return new List<long>();
            }

            if (term == 1)
                return new List<long>();
            if (term == 2)
                return new List<long> { 2 };

            bool[] naturalNumbers = new bool[term];
            naturalNumbers[0] = true;
            naturalNumbers[1] = true;

            for (int i = 2; i <= term; i++)
            {
                if (i < maxNumber)
                    naturalNumbers = flagNonPrimesUpToMax(i, naturalNumbers);
                else
                    break;
            }

            List<long> returnList = new List<long>();

            for (int j = 0; j < naturalNumbers.Length; j++)
            {
                if (!naturalNumbers[j])
                {
                    returnList.Add(j);
                }
            }

            return returnList;
        }

        public static bool[] flagNonPrimesUpToMax(long term, bool[] list)
        {
            for(long i = term*2; i < list.Length; i+= term)
            {
                list[i] = true;
            }
            return list;
        }

        //Fails when max > ~8000, due to stack size limitations. 
        private static bool[] flagNonPrimesUpToMaxRecursive(long term, bool[] list, long max, long multiplier)
        {
            if (term * multiplier >= list.Length || term * multiplier >= max)
            {
                return list;
            }
                
            else
            {
                if(1 == multiplier)
                {
                    multiplier++;
                    return (flagNonPrimesUpToMaxRecursive(term, list, max, multiplier));
                }
                else
                {
                    list[term*multiplier] = true;
                    multiplier++;
                    return (flagNonPrimesUpToMaxRecursive(term, list, max, multiplier));
                }
            }
        }
        #endregion
    }
}
